# W2017: CPSC 526 Network Security
# Assignment 4: Personal Firewall
# Author: Daniel LaCoste

import sys
import fileinput
import ipaddress

# params: 
#   • rule_table: 2D array generated by config file
#   • packet_array: current packet to check against rule_table table
# returns:
#   • action: the action the program incurs on the packet
#   • rule_num: the corresponding line number in the rule file
def check_packet(rule_table, packet_array):
    rule_num = 1
    packet_direction = packet_array[0]
    packet_ip = packet_array[1]
    packet_port = packet_array[2]
    packet_flag = packet_array[3]

    for rule in rule_table:
        # check if the rule line is empty
        if len(rule) == 1:
            rule_num += 1
            continue

        rule_direction = rule[0]
        rule_action = rule[1]
        rule_ip = rule[2]
        rule_port = rule[3]

        # rule in config file does not have optional flag
        if len(rule) == 4:
            # check matching direction
            if rule_direction != packet_direction:
                rule_num += 1
                continue
            # check ip address of packet against the rules
            if rule_ip == '*' or ipaddress.IPv4Address(packet_ip) in ipaddress.IPv4Network(rule_ip, strict=False):
                if rule_port == '*' or packet_port in rule_port.split(','):
                    return rule_action, rule_num

        # rule in config file does have optional flag
        if len(rule) == 5:
            rule_flag = rule[4]
            if rule_flag == 'established':
                if packet_flag == '1':
                    if rule_direction != packet_direction:
                        rule_num += 1
                        continue
                    if rule_ip == '*' or ipaddress.IPv4Address(packet_ip) in ipaddress.IPv4Network(rule_ip, strict=False):
                        if rule_port == '*' or packet_port in rule_port.split(','):
                            return rule_action, rule_num
        rule_num += 1

    # drop the packet..
    print('drop() ' + ' '.join(packet_array))
    return 'drop', 0

# params:
#   • rule: take in a rule from the config file
# returns:
#   • rule_list: a parsed/massaged rule, in list format
def read_rule(rule):
    rule_split= rule.split() 
    rule_list = rule_split[:5]

    # check if the rule line is empty 
    if len(rule_list) == 1:
        return rule_list

    direction = rule_list[0]
    action = rule_list[1]
    ip = rule_list[2]
    port = rule_list[3]

    # check for comment only line
    if rule_list[0].startswith('#'):
        rule_list = rule_list.clear()
        return rule_list

    # check rule direction
    if direction not in ['in', 'out']:
        print("Error - Rule direction must be 'in' or 'out':", direction)
        sys.exit(0)

    # check rule action
    if action not in ['accept', 'deny', 'drop']:
        print("Error - Invalid rule action, use 'accept','deny', or 'drop':", action)
        sys.exit(0)

    # check IP
    if ip != '*':
        try:
            ipaddress.IPv4Network(ip, strict=False)
        except ValueError:
            print("Error - Rule address/netmask is invalid for IPv4:", ip)
            sys.exit(0)

    # check port
    if port != '*':
        if port.replace(',','').isdigit() == False:
            print("Error - Rule port is not an integer:", port)
            sys.exit(0)
        portList = port.split(',')
        for portI in portList:
            if int(portI) not in range(0, 65536):
                print("Error - Rule port is not in range of 0-65535:", portI)
                sys.exit(0)

    # check flag
    if len(rule_list) == 5:
        if rule_list[4].startswith('#'):
            rule_list.pop[4]
        flag = rule_list[4]
        if flag != 'established':
            print("Error - Flag must be 'established' or not exist:", flag)
            sys.exit(0)

    return rule_list

# params:
#   • packet: the current packet being read
# returns:
#   • packet_list: a parsed/massaged packet, in list format
def read_packet(packet):
    packet_clear = packet.split()
    packet_list = packet_clear[:4]

    direction = packet_list[0]
    ip = packet_list[1]
    port = packet_list[2]
    flag = packet_list[3]

    # check for comment only lines
    if packet_list[0].startswith('#'):
        packet_list = packet_list.clear()
        return packet_list 

    # check packet direction
    if direction not in ['in', 'out']:
        print("Error - Packet direction must be 'in' or 'out':", direction)
        sys.exit(0)

    # check packet IP validity
    try:
        ipaddress.IPv4Network(ip, strict=False)
    except ValueError:
        print("Error - Packet address/netmask is invalid for IPv4:", ip)
        sys.exit(0)

    # check packet port validity
    if port.isdigit() == False:
        print("Error - Port is not an integer:", port)
        sys.exit(0)
    if int(port) not in range(0, 65536):
        print("Error - Port is not in range of 0-65535:", port)
        sys.exit(0)

    # check flag presence
    if flag not in ['0', '1']:
        print("Error - Invalid packet flag, use '0' (not established) or '1' (established):", flag)
        sys.exit(0)

    return packet_list 

# returns:
#   • args: the first and only argument to the program should be the config/rule file
def get_args():
    args = sys.argv[1] 
    return args

# begin magic
if __name__ == "__main__":
    config_file = get_args()

    with open(config_file) as cfg:
        rule_table = []

        # generate the 2D array via the config file
        for rule in cfg:
            ruleLine = rule.strip()

            # skip blank lines
            if not ruleLine:
                rule_table.append([''])
                continue

            rule_list = read_rule(rule)
            # skip comment-only lines
            if rule_list is None: 
                rule_table.append([''])
                continue

            # add the rule!
            rule_table.append(rule_list)

    # read packets via stdin
    for packet in sys.stdin.readlines():
        packet_line= packet.strip()

        # skip blank lines
        if not packet_line: 
            continue

        packet_array = read_packet(packet)
        # skip comment-only lines
        if packet_array is None: 
            continue

        # invalid IPv4 address
        if not packet_array: 
            action = 'drop'
            line_num = 0
        else:
            action, line_num = check_packet(rule_table, packet_array)

        if line_num == 0:
            pass
        else:
            print(action + '(' + str(line_num) + ') ' + ' '.join(packet_array))
